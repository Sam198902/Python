# 
Python 有四种数据结构，分别是：列表、字典、元组、集合。我们先从整体上认识一下这四种数据结构：
```
list = [val1,val2,val3,val4] #列表
dict = {key1:val1,key2:val2} #字典
tuple = (val1,val2,val3,val4) #元组
set = {val1,val2,val3,val4}	#集合
```
## 2.1 列表（List）
* 列表中的每个元素都是可变的；
* 列表中的元素是有序的，也就是说每个元素都有一个位置；

列表中可以容纳 Python 中的任何对象。如下：
```
all_in_list = [
    1, #整数
    1.0, #浮点数
    'a word', #字符串
    print(1), #函数
    True, #布尔值
    [1,2], #列表中套列表
    (1,2), #元祖
    {'key':'value'} #字典
]
```
另外，对于数据的操作，最常见的为增删改查。在此就省略了，网上找下相应函数练习下即可。
### 1、Python列表脚本操作符
列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。
如下所示：

| Python 表达式   | 结果   | 描述   | 
|:----|:----|:----|
| len([1, 2, 3])   | 3   | 长度   | 
| [1, 2, 3] + [4, 5, 6]   | [1, 2, 3, 4, 5, 6]   | 组合   | 
| ['Hi!'] * 4   | ['Hi!', 'Hi!', 'Hi!', 'Hi!']   | 重复   | 
| 3 in [1, 2, 3]   | True   | 元素是否存在于列表中   | 
| for x in [1, 2, 3]: print(x, end=" ")   | 1 2 3   | 迭代   | 

### 2、Python列表截取与拼接
Python的列表截取与字符串操作类型，如下所示：
L=['aaa', 'bbb', 'ccc']

| Python 表达式   | 结果   | 描述   | 
|:----|:----|:----|
| L[2]   | 'ccc'   | 读取第三个元素   | 
| L[-2]   | 'bbb'   | 从右侧开始读取倒数第二个元素: count from the right   | 
| L[1:]   | ['bbb', 'ccc']   | 输出从第二个元素开始后的所有元素   | 

列表还支持拼接操作：
```
>>>squares = [1, 4, 9, 16, 25]
>>> squares += [36, 49, 64, 81, 100]
>>> squares
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
>>>
```
### 3、嵌套列表
使用嵌套列表即在列表里创建其它列表，例如：
```
>>>a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
```
### 4、Python列表函数&方法
Python包含以下函数:

| 序号   | 函数   | 
|:----|:----|
| 1   | len(list)  列表元素个数   | 
| 2   | max(list)  返回列表元素最大值   | 
| 3   | min(list)   返回列表元素最小值   | 
| 4   | list(seq)   将元组转换为列表   | 

Python包含以下方法:

| 序号   | 方法   | 
|:----|:----|
| 1   | list.append(obj)   在列表末尾添加新的对象   | 
| 2   | list.count(obj)   统计某个元素在列表中出现的次数   | 
| 3   | list.extend(seq)   在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）   | 
| 4   | list.index(obj)   从列表中找出某个值第一个匹配项的索引位置   | 
| 5   | list.insert(index, obj)    将对象插入列表   | 
| 6   | list.pop([index=-1])   移除列表中的一个元素（默认最后一个元素），并且返回该元素的值   | 
| 7   | list.remove(obj)   移除列表中某个值的第一个匹配项   | 
| 8   | list.reverse()   反向列表中元素   | 
| 9   | list.sort( key=None, reverse=False)   对原列表进行排序   | 
| 10   | list.clear()   清空列表   | 
| 11   | list.copy()  复制列表   | 

### 5、实例
```
#-*-coding:utf-8-*-
#-----------------------list的使用----------------------------------

# 1.一个产品，需要列出产品的用户，这时候就可以使用一个 list 来表示
user=['liangdianshui','twowater','两点水']
print('1.产品用户')
print(user)

# 2.如果需要统计有多少个用户，这时候 len() 函数可以获的 list 里元素的个数
len(user)
print('\n2.统计有多少个用户')
print(len(user))

# 3.此时，如果需要知道具体的用户呢？可以用过索引来访问 list 中每一个位置的元素，索引是0从开始的
print('\n3.查看具体的用户')
print(user[0]+','+user[1]+','+user[2])

# 4.突然来了一个新的用户，这时我们需要在原有的 list 末尾加一个用户
user.append('茵茵')
print('\n4.在末尾添加新用户')
print(user)

# 5.又新增了一个用户，可是这个用户是 VIP 级别的学生，需要放在第一位，可以通过 insert 方法插入到指定的位置
# 注意：插入数据的时候注意是否越界，索引不能超过 len(user)-1
user.insert(0,'VIP用户')
print('\n5.指定位置添加用户')
print(user)

# 6.突然发现之前弄错了，“茵茵”就是'VIP用户'，因此，需要删除“茵茵”；pop() 删除 list 末尾的元素
user.pop()
print('\n6.删除末尾用户')
print(user)

# 7.过了一段时间，用户“liangdianshui”不玩这个产品，删除了账号
# 因此需要要删除指定位置的元素，用pop(i)方法，其中i是索引位置
user.pop(1)
print('\n7.删除指定位置的list元素')
print(user)

# 8.用户“两点水”想修改自己的昵称了
user[2]='三点水'
print('\n8.把某个元素替换成别的元素')
print(user)

# 9.单单保存用户昵称好像不够好，最好把账号也放进去
# 这里账号是整数类型，跟昵称的字符串类型不同，不过 list 里面的元素的数据类型是可以不同的
# 而且 list 元素也可以是另一个 list
newUser=[['VIP用户',11111],['twowater',22222],['三点水',33333]]
print('\n9.不同元素类型的list数据')
print(newUser)
```

## 2.2 元组（Tuple）
元组可以理解为一个稳固版的列表，因为元组是不可以修改的，因此在列表中的存在的方法均不可以使用在元组上，但是元组是可以被查看索引的，方式和列表一样。
```
letters = ('a, 'b', 'c', 'd')
letters[0]
```

### 1、不可修改
tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：
```
>>> classmates = ('Michael', 'Bob', 'Tracy')
```
现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。

不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

### 2、tuple的陷阱
当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：
```
>>> t = (1, 2)
>>> t
(1, 2)
```
如果要定义一个空的tuple，可以写成()：
```
>>> t = ()
>>> t
()
```
但是，要定义一个只有1个元素的tuple，如果你这么定义：
```
>>> t = (1)
>>> t
1
```
定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。

所以，只有1个元素的tuple定义时必须加一个**逗号****,**，来消除歧义：
```
>>> t = (1,)
>>> t
(1,)
```
Python在显示只有1个元素的tuple时，也会加一个**逗号****,**，以免你误解成数学计算意义上的括号。
### 3、“可变的”tuple：
```
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
```
这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？
别急，我们先看看定义的时候tuple包含的3个元素：
![图片](https://www.liaoxuefeng.com/files/attachments/923973516787680/0)
当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：
![图片](https://www.liaoxuefeng.com/files/attachments/923973647515872/0)
表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。

### 4、元组运算符
与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。

| Python 表达式   | 结果   | 描述   | 
|:----|:----|:----|
| len((1, 2, 3))   | 3   | 计算元素个数   | 
| (1, 2, 3) + (4, 5, 6)   | (1, 2, 3, 4, 5, 6)   | 连接   | 
| ('Hi!',) * 4   | ('Hi!', 'Hi!', 'Hi!', 'Hi!')   | 复制   | 
| 3 in (1, 2, 3)   | True   | 元素是否存在   | 
| for x in (1, 2, 3): print (x,)   | 1 2 3   | 迭代   | 

### 5、元组内置函数
Python元组包含了以下内置函数

| 方法   | 描述   | 
|:----|:----|
| cmp(tuple1, tuple2)   | 比较两个元组元素   | 
| len(tuple)   | 计算元组元素个数   | 
| max(tuple)   | 返回元组中元素最大值   | 
| min(tuple)   | 返回元组中元素最小值   | 
| tuple(seq)   | 将列表转换为元组   | 


## 2.3 字典（Dict）
* 字典中数据必须是以键值对的形式出现的；
* 逻辑上讲，键是不能重复的；
* 字典中的键（key）是不可变的，也就是无法修改的，而值（value）是可变的，可修改的，可以是任何对象。

下面是个例子：
```
NASDAQ_code = {
    'BIDU':'Baidu',
    'SINA':'Sina',
    'YOKU':'Youku'
}
```
* 一个字典中键与值并不能脱离对方而存在，如果你写成了** ****{'BIDU':}** 会引发一个语法错误：invalid syntax。
* 如果试着将一个可变（mutable）的元素作为 key 来构建字典，比如列表：**key_test = {[]:'a Test'}** ，则会报一个错：unhashable type:'list'。
* 同时字典中的键值不会重复，即便你这么做，相同的键值也只能出现一次：**a = {'key':123,'key':123}**** **。

备注：
* 列表中用来添加多个元素的方法为extend，在字典中添加多个元素的方法为update()
* 字典是不能切片的，即这样的写法是错误的：chart[1:4]
### 1、键-值（key-value）存储
dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：
```
names = ['Michael', 'Bob', 'Tracy']
scores = [95, 75, 85]
```
给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。
如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：
```
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95
```

### 2、为什么dict查找速度这么快？
因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。
第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。
dict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。

### 3、通过key的操作
你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。
* **修改value**

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
```
>>> d['Adam'] = 67
>>> d['Adam']
67
```
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
```
>>> d['Jack'] = 90
>>> d['Jack']
90
>>> d['Jack'] = 88
>>> d['Jack']
88
```

* **检测key**

如果key不存在，dict就会报错：
```
>>> d['Thomas']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Thomas'
```

要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
```
>>> 'Thomas' in d
False
```
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
```
>>> d.get('Thomas')
>>> d.get('Thomas', -1)
-1
```
注意：返回None的时候Python的交互环境不显示结果。

* **删除key**

要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
```
>>> d.pop('Bob')
75
>>> d
{'Michael': 95, 'Tracy': 85}
```

请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

* **dict特点**

和list比较，dict有以下几个特点：
1. 查找和插入的速度极快，不会随着key的增加而变慢；
2. 需要占用大量的内存，内存浪费多。

而list相反：
1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

所以，dict是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是**不可变对象**。

这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：
```
>>> key = [1, 2, 3]
>>> d[key] = 'a list'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```
### 注意字典的 key 是区分大小写的
### 4、字典内置函数&方法
Python字典包含了以下内置函数：

| 序号   | 函数及描述   | 实例   | 
|:----|:----|:----|:----:|
| 1   | len(dict)计算字典元素个数，即键的总数。   | >>> dict = {'Name': 'aaa', 'Age': 7, 'Class': 'First'}  >>> len(dict)  3     | 
| 2   | str(dict)输出字典，以可打印的字符串表示。   | >>> dict = {'Name': 'aaa', 'Age': 7, 'Class': 'First'}  >>> str(dict)  "{'Name': 'aaa', 'Class': 'First', 'Age': 7}"     | 
| 3   | type(variable)返回输入的变量类型，如果变量是字典就返回字典类型。   | >>> dict = {'Name': 'aaa', 'Age': 7, 'Class': 'First'}  >>> type(dict)  <class 'dict'>     | 

Python字典包含了以下内置方法：

| 方法和函数   | 描述   | 
|:----|:----|
| cmp(dict1, dict2)   | 比较两个字典元素   | 
| len(dict)   | 计算字典元素个数   | 
| str(dict)   | 输出字典可打印的字符串表示   | 
| type(variable)   | 返回输入的变量类型，如果变量是字典就返回字典类型   | 
| dict.clear()   | 删除字典内所有元素   | 
| dict.copy()   | 返回一个字典的浅复制   | 
| dict.values()   | 以列表返回字典中的所有值   | 
| popitem()   | 随机返回并删除字典中的一对键和值   | 
| dict.items()   | 以列表返回可遍历的(键, 值) 元组数组   | 


## 3.4 集合（Set）
* 集合则更接近数学上集合的概念。每一个集合中是的元素是无序的、不重复的任意对象，我们可以通过集合去判断数据的从属关系，有时还可以通过集合把数据结构中重复的元素减掉。
* 集合不能被切片也不能被索引，除了做集合运算之外，集合元素可以被添加还有删除：
```
a_set = {1,2,3,4}
a_set.add(5)
a_set.discard(5)
```

set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
### 1、集合基本操作
要创建一个set，需要提供一个list作为输入集合：
```
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}
```
注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。

重复元素在set中自动被过滤：
```
>>> s = set([1, 1, 2, 2, 3, 3])
>>> s
{1, 2, 3}
```

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：
```
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
```

通过remove(key)方法可以删除元素：
```
>>> s.remove(4)
>>> s
{1, 2, 3}
```

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：
```
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}
```
set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。
### 2、集合内置方法完整列表

| 方法   | 描述   | 
|:----|:----|
| add()   | 为集合添加元素   | 
| clear()   | 移除集合中的所有元素   | 
| copy()   | 拷贝一个集合   | 
| difference()   | 返回多个集合的差集   | 
| difference_update()   | 移除集合中的元素，该元素在指定的集合也存在。   | 
| discard()   | 删除集合中指定的元素   | 
| intersection()   | 返回集合的交集   | 
| intersection_update()   | 删除集合中的元素，该元素在指定的集合中不存在。   | 
| isdisjoint()   | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。   | 
| issubset()   | 判断指定集合是否为该方法参数集合的子集。   | 
| issuperset()   | 判断该方法的参数集合是否为指定集合的子集   | 
| pop()   | 随机移除元素   | 
| remove()   | 移除指定元素   | 
| symmetric_difference()   | 返回两个集合中不重复的元素集合。   | 
| symmetric_difference_update()   | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。   | 
| union()   | 返回两个集合的并集   | 
| update()   | 给集合添加元素   | 

## 3.5  再议不可变对象
上面我们讲了，str是不变对象，而list是可变对象。
对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：
```
>>> a = ['c', 'b', 'a']
>>> a.sort()
>>> a
['a', 'b', 'c']
```
而对于不可变对象，比如str，对str进行操作呢：
```
>>> a = 'abc'
>>> a.replace('a', 'A')
'Abc'
>>> a
'abc'
```
虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？
我们先把代码改成下面这样：
```
>>> a = 'abc'
>>> b = a.replace('a', 'A')
>>> b
'Abc'
>>> a
'abc'
```
要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'：
┌───┐                  ┌───────┐
 │       a     │─────>│          'abc'          │
└───┘                  └───────┘
当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：
┌───┐                  ┌───────┐
 │ a           │─────>│        'abc'            │
└───┘                  └───────┘
┌───┐                  ┌───────┐
 │ b           │─────>│        'Abc'           │
└───┘                  └───────┘
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
### 
## 3.6 数据结构的一些技巧
### 1、多重循环
如下：
![图片](https://img-1256179949.cos.ap-shanghai.myqcloud.com/18-9-15-56843862.jpg)
代码演示：
```
for a, b in zip(num, str):
    print(b, 'is', a)
```

### 2、推导式
列表推导式的用法很好理解，可以简单地看成两部分。如下图：
![图片](https://img-1256179949.cos.ap-shanghai.myqcloud.com/18-9-15-2700791.jpg)
>红色虚线后面的是我们熟悉的 for 循环的表达式，而虚线前面的可以认为是我们想要放在列表中的元素。

代码演示：
```
a = []
for i in range(1, 11):
    a.append(i)
```
可以换成列表解析的方式来写：
```
b = [i for i in range(1, 11)]
```
列表解析式不仅方便，并且在执行效率上要远远胜过前者。

