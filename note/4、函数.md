# 
举些你可能已经使用过的函数例子：
```
判断数据类型：type(str) 
字符串类型数据转为整数型：int(str)
...
```
通过观察规律不难发现，Python 中所谓的使用函数就是把你要处理的对象放到一个名字后面的括号就可以了。简单的来说，函数就是这么使用，可以往里面塞东西得到处理结果。这样的函数在 Python 中还有这些：
![图片](https://img-1256179949.cos.ap-shanghai.myqcloud.com/18-9-15-82241521.jpg)
以 Python3.6 版本为例，一个有 68 个这样的函数，它们被称为内建函数。这里內建的是指这些函数为安装好了 Python 就可以使用。

可以[https://docs.python.org/3/library/functions.html#abs](https://docs.python.org/3/library/functions.html#abs)，查看所有内置函数

## 4.1 函数格式
定义函数的格式：
![图片](https://img-1256179949.cos.ap-shanghai.myqcloud.com/18-9-15-36412659.jpg)

其中，def 和 return 为关键字。
注意： 函数缩进后面的语句被称为是语句块，缩进是为了表名语句的逻辑与从属关系。缩进这个问题不能忽视，否则会导致代码无法成功运行，这里需要特别注意。

## 4.2 函数参数
① 位置参数，举例，看代码：
```
def trapezoid_area(base_up, base_down, height):
    return 1/2 * (base_up + base_down) * height
```
接下来我们开始调用该函数：
```
trapezoid_area(1,2,3)
```
不难看出，填入的参数1，2，3分别对应着参数 base_up，base_down 和 height。这种传入参数的方式被称作为位置参数。

② 关键词参数：在函数调用的时候，将每个参数名称后面赋予一个我们想要传入的值，如调用 fun1 函数时候：fun1(a=1, b=2, c=3)。
看下图：
![图片](https://img-1256179949.cos.ap-shanghai.myqcloud.com/18-9-15-78354686.jpg)
* 第一行的函数参数按照反序传入，因为是关键词参数，所以并不影响函数正常运作；
* 第二行的函数参数反序传入，但是到了第三个却变成了位置函数，遗憾的是这种方式是错误的语法，因为如果按照位置来传入，最后一个应该是参数 height 的位置。但是前面 height 已经按照名称传入了值3，所以是冲突的。
* 第三行的函数参数正序传入，前两个是以关键字的方式传入，最后一个以位置参数传入，但是位置参数不能再关键词参数后面，所以是错误的。
* 第四行的函数参数正序传入，前两个是以位置的方式传入，最后一个以关键字参数传入，这个函数是可以正常运行的。

③ 不定长参数
有时我们在设计函数接口的时候，可会需要可变长的参数。也就是说，我们事先无法确定传入的参数个数。

Python 提供了一种**元组**的方式来接受没有直接定义的参数。这种方式在参数前边加**星号 ******* 。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。例如：
```
def print_user_info( name ,  age  , sex = '男' , * hobby):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex) ,end = ' ' )
    print('爱好：{}'.format(hobby))
    return;

# 调用 print_user_info 函数
print_user_info( '小明' , 25, '男', '打篮球','打羽毛球','跑步')
```
输出的结果：
```
昵称：小明 年龄：25 性别：男 爱好：('打篮球', '打羽毛球', '跑步')
```
通过输出的结果可以知道，* hobby 是可变参数，且 hobby 其实就是一个 tuple （元组）。

可变长参数也支持关键参数，没有被定义的关键参数会被放到一个字典里。这种方式即是在参数前边加** ********，更改上面的示例如下：
```
def print_user_info( name ,  age  , sex = '男' , ** hobby ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex) ,end = ' ' )
    print('爱好：{}'.format(hobby))
    return;

# 调用 print_user_info 函数
print_user_info( name = '小明' , age = 25 , sex = '男', hobby = ('打篮球','打羽毛球','跑步'))
```
输出的结果：
```
昵称：小明 年龄：24 性别：男 爱好：{'hobby': ('打篮球', '打羽毛球', '跑步')}
```
通过对比上面的例子和这个例子，可以知道，* hobby 是可变参数，且 hobby 其实就是一个 tuple （元组），** hobby是关键字参数，且 hobby 就是一个 dict （字典）。

④  只接受关键字参数
关键字参数使用起来简单，不容易参数出错，那么有些时候，我们定义的函数希望某些参数强制使用关键字参数传递，这时候该怎么办呢？将强制关键字参数放到某个*参数或者单个*后面就能达到这种效果,比如：
```
def print_user_info( name , *, age, sex = '男' ):
    # 打印用户信息
    print('昵称：{}'.format(name) , end = ' ')
    print('年龄：{}'.format(age) , end = ' ')
    print('性别：{}'.format(sex))
    return;

# 调用 print_user_info 函数
print_user_info( name = '小明' ,age = 25 , sex = '男' )

# 这种写法会报错，因为 age ，sex 这两个参数强制使用关键字参数
#print_user_info( '小明' , 25 , '男' )
print_user_info('小明',age='22',sex='男')
```
通过例子可以看，如果 age , sex 不用关键字参数是会报错的。
## 4.3 匿名函数
有没有想过定义一个很短的回调函数，但又不想用 def 的形式去写一个那么长的函数，那么有没有快捷方式呢？——答案是有的。
Python 使用 lambda 来创建匿名函数，也就是不再使用 def 语句这样标准的形式定义一个函数。
匿名函数主要有以下特点：
* lambda 只是一个表达式，函数体比 def 简单很多。
* lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。
* lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。

基本语法：**lambda [arg1 [,arg2,.....argn]]:expression**
示例：
```
sum = lambda num1 , num2 : num1 + num2;
print( sum( 1 , 2 ) )
```
输出的结果： 3

注意：**尽管 lambda 表达式允许你定义简单函数，但是它的使用是有限制的。 你只能指定单个表达式，它的值就是最后的返回值。也就是说不能包含其他的语言特性了， 包括多个语句、条件表达式、迭代以及异常处理等等。**

匿名函数中，有一个特别需要注意的问题，比如，把上面的例子改一下：
```
num2 = 100
sum1 = lambda num1 : num1 + num2 ;

num2 = 10000
sum2 = lambda num1 : num1 + num2 ;

print( sum1( 1 ) )
print( sum2( 1 ) )
```
你会认为输出什么呢？第一个输出是 101，第二个是 10001，结果不是的，输出的结果是这样：
```
10001
10001
```
这主要在于 lambda 表达式中的 num2 是一个自由变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。所以建议还是遇到这种情况还是使用第一种解法。
## 4.4 返回多个值
函数可以返回多个值吗？答案是肯定的。
比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：
```
import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
```
import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。
然后，我们就可以同时获得返回值：
```
>>> x, y = move(100, 100, 60, math.pi / 6)
>>> print(x, y)
151.96152422706632 70.0
```
但其实这只是一种假象，Python函数返回的仍然是单一值：
```
>>> r = move(100, 100, 60, math.pi / 6)
>>> print(r)
(151.96152422706632, 70.0)
```
原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

## 4.5 递归函数
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。

举个例子，我们来计算阶乘 n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：
```
fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n
```
所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。
于是，fact(n)用递归的方式写出来就是：
```
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```
上面就是一个递归函数。可以试试：
```
>>> fact(1)
1
>>> fact(5)
120
>>> fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```
如果我们计算fact(5)，可以根据函数定义看到计算过程如下：
```
===> fact(5)
===> 5 * fact(4)
===> 5 * (4 * fact(3))
===> 5 * (4 * (3 * fact(2)))
===> 5 * (4 * (3 * (2 * fact(1))))
===> 5 * (4 * (3 * (2 * 1)))
===> 5 * (4 * (3 * 2))
===> 5 * (4 * 6)
===> 5 * 24
===> 120
```
递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
### 1、栈溢出
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：
```
>>> fact(1000)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in fact
  ...
  File "<stdin>", line 4, in fact
RuntimeError: maximum recursion depth exceeded in comparison
```

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：
```
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```
可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。
fact(5)对应的fact_iter(5, 1)的调用如下：
```
===> fact_iter(5, 1)
===> fact_iter(4, 5)
===> fact_iter(3, 20)
===> fact_iter(2, 60)
===> fact_iter(1, 120)
===> 120
```
尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。


## 4.6 闭包
### 1、了解闭包
通过解决一个需求问题来了解闭包。
>这个需求是这样的，我们需要一直记录自己的学习时间，以分钟为单位。就好比我学习了 2 分钟，就返回 2 ，然后隔了一阵子，我学习了 10 分钟，那么就返回 12 ，像这样把学习时间一直累加下去。

面对这个需求，我们一般都会创建一个全局变量来记录时间，然后用一个方法来新增每次的学习时间，通常都会写成下面这个形式：
```
time = 0

def insert_time(min):
    time = time + min
    return  time

print(insert_time(2))
print(insert_time(10))
```
其实，这个在 Python 里面是会报错的。会报如下错误：UnboundLocalError: local variable 'time' referenced before assignment
那是因为，在 Python 中，**如果一个函数使用了和全局变量相同的名字且改变了该变量的值，那么该变量就会变成局部变量**，那么就会造成在函数中我们没有进行定义就引用了，所以会报该错误。
我们可以使用 global 关键字，具体修改如下：
```
time = 0

def insert_time(min):
    global  time
    time = time + min
    return  time

print(insert_time(2))
print(insert_time(10))
```
输出结果如下：
```
2
12
```
可是啊，这里使用了全局变量，我们在开发中能尽量避免使用全局变量的就尽量避免使用。因为不同模块，不同函数都可以自由的访问全局变量，可能会造成全局变量的不可预知性。比如程序员甲修改了全局变量 time 的值，然后程序员乙同时也对 time 进行了修改，如果其中有错误，这种错误是很难发现和更正的。

这时候我们使用闭包来解决一下，先直接看代码：
```
time = 0

def study_time(time):
    def insert_time(min):
        nonlocal  time
        time = time + min
        return time

    return insert_time

f = study_time(time)
print(f(2))
print(time)
print(f(10))
print(time)
```
输出结果如下：
```
2
0
12
0
```
这里最直接的表现就是全局变量 time 至此至终都没有修改过，这里还是用了 nonlocal 关键字，表示在函数或其他作用域中使用外层（非全局）变量。那么上面那段代码具体的运行流程是怎样的。我们可以看下下图：
![图片](https://img-1256179949.cos.ap-shanghai.myqcloud.com/18-9-15-76967350.jpg)
**这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为： 闭包****。** 更加直接的表达方式就是，当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。

**也可以这样解释：在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。**

一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。

```
#闭包函数的实例
# outer是外部函数 a和b都是外函数的临时变量
def outer( a ):
    b = 10
    # inner是内函数
    def inner():
        #在内函数中 用到了外函数的临时变量
        print(a+b)
    # 外函数的返回值是内函数的引用
    return inner

if __name__ == '__main__':
    # 在这里我们调用外函数传入参数5
    #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo
    # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数
    demo = outer(5)
    # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量
    # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数
    demo() # 15
    demo2 = outer(7)
    demo2()#17
```

### 2、名词解释
* 外函数返回了内函数的引用

引用是什么？在python中一切都是对象，包括整型数据1，函数，其实是对象。

当我们进行a=1的时候，实际上在内存当中有一个地方存了值1，然后用a这个变量名存了1所在内存位置的引用。引用就好像c语言里的指针，大家可以把引用理解成地址。a只不过是一个变量名字，a里面存的是1这个数值所在的地址，就是a里面存了数值1的引用。

相同的道理，当我们在python中定义一个函数def demo():  的时候，内存当中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名字，它里面存了这个函数所在位置的引用而已。我们还可以进行x = demo， y = demo， 这样的操作就相当于，把demo里存的东西赋值给x和y，这样x 和y 都指向了demo函数所在的引用，在这之后我们可以用x() 或者 y() 来调用我们自己创建的demo() ，调用的实际上根本就是一个函数，x、y和demo三个变量名存了同一个函数的引用。


有了上面的解释，我们可以继续说，返回内函数的引用是怎么回事了。对于闭包，在外函数outer中 最后return inner，我们在调用外函数 demo = outer() 的时候，outer返回了inner，inner是一个函数的引用，这个引用被存入了demo中。所以接下来我们再进行demo() 的时候，相当于运行了inner函数。

 同时我们发现，一个函数，如果函数名后紧跟一对括号，相当于现在我就要调用这个函数，如果不跟括号，相当于只是一个函数的名字，里面存了函数所在位置的引用。

* 外函数把临时变量绑定给内函数

按照我们正常的认知，一个函数结束的时候，会把自己的临时变量都释放还给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特别的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量送给内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。

 在编写的实例中，两次调用外部函数outer,分别传入的值是5和7。内部函数只定义了一次，我们发现调用的时候，内部函数是能识别外函数的临时变量是不一样的。python中一切都是对象，虽然函数我们只定义了一次，但是外函数在运行的时候，实际上是按照里面代码执行的，外函数里创建了一个函数，我们每次调用外函数，它都创建一个内函数，虽然代码一样，但是却创建了不同的对象，并且把每次传入的临时变量数值绑定给内函数，再把内函数引用返回。虽然内函数代码是一样的，但其实，我们每次调用外函数，都返回不同的实例对象的引用，他们的功能是一样的，但是它们实际上不是同一个函数对象。

* 闭包中内函数修改外函数局部变量

在闭包内函数中，我们可以随意使用外函数绑定来的临时变量，但是如果我们想修改外函数临时变量数值的时候发现出问题了！咋回事捏？？！！（哇哇大哭）

在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:
* global 声明全局变量 
* 全局变量是可变类型数据的时候可以修改

  
在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候：
* 在python3中，可以用**nonlocal** 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。
* 在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。

```
#修改闭包变量的实例
# outer是外部函数 a和b都是外函数的临时变量
def outer( a ):
    b = 10  # a和b都是闭包变量
    c = [a] #这里对应修改闭包变量的方法2
    # inner是内函数
    def inner():
        #内函数中想修改闭包变量
        # 方法1 nonlocal关键字声明
        nonlocal  b
        b+=1
        # 方法二，把闭包变量修改成可变数据类型 比如列表
        c[0] += 1
        print(c[0])
        print(b)
    # 外函数的返回值是内函数的引用
    return inner

if __name__ == '__main__':

    demo = outer(5)
    demo() # 6  11
```

还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量。

```
def outer(x):
    def inner(y):
        nonlocal x
        x+=y
        return x
    return inner


a = outer(10)
print(a(1)) //11
print(a(3)) //14
```

### 3、验证闭包
有没有什么办法来验证一下这个函数就是闭包呢？
有的，所有函数都有一个** ****__closure__**** **属性，如果函数是闭包的话，那么它返回的是一个由 cell 组成的元组对象。cell 对象的 cell_contents 属性就是存储在闭包中的变量。看代码：
```
time = 0
def study_time(time):
    def insert_time(min):
        nonlocal  time
        time = time + min
        return time
    return insert_time
    
f = study_time(time)
print(f.__closure__)
print(f(2))
print(time)
print(f.__closure__[0].cell_contents)
print(f(10))
print(time)
print(f.__closure__[0].cell_contents)
```
打印结果为：
```
(<cell at 0x0000000000410C48: int object at 0x000000001D6AB420>,)
2
0
2
12
0
12
```
从打印结果可见，传进来的值一直存储在闭包的 cell_contents 中,因此，这也就是闭包的最大特点，可以将父函数的变量与其内部定义的函数绑定。就算生成闭包的父函数已经释放了，闭包仍然存在。

闭包的过程其实好比类（父函数）生成实例（闭包），不同的是父函数只在调用时执行，执行完毕后其环境就会释放，而类则在文件执行时创建，一般程序执行完毕后作用域才释放，因此对一些需要重用的功能且不足以定义为类的行为，使用闭包会比使用类占用更少的资源，且更轻巧灵活。

注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：
```
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
```
在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。
你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：
```
>>> f1()
9
>>> f2()
9
>>> f3()
9
```
全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

 **返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**

如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
```
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
```
再看看结果：
```
>>> f1, f2, f3 = count()
>>> f1()
1
>>> f2()
4
>>> f3()
9
```
缺点是代码较长，可利用lambda函数缩短代码。

### 4、闭包作用
* **当闭包执行完后，仍然能够保持住当前的运行环境。**

比如说，如果你希望函数的每次执行结果，都是基于这个函数上次的运行结果。我以一个类似棋盘游戏的例子来说明。假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，步长(step)，该函数控制棋子的运动。棋子运动的新的坐标除了依赖于方向和步长以外，当然还要根据原来所处的坐标点，用闭包就可以保持住这个棋子原来所处的坐标。
```
origin = [0, 0]  # 坐标系统原点  
legal_x = [0, 50]  # x轴方向的合法坐标  
legal_y = [0, 50]  # y轴方向的合法坐标  
def create(pos=origin):  
    def player(direction,step):  
        # 这里应该首先判断参数direction,step的合法性，比如direction不能斜着走，step不能为负等  
        # 然后还要对新生成的x，y坐标的合法性进行判断处理，这里主要是想介绍闭包，就不详细写了。  
        new_x = pos[0] + direction[0]*step  
        new_y = pos[1] + direction[1]*step  
        pos[0] = new_x  
        pos[1] = new_y  
        #注意！此处不能写成 pos = [new_x, new_y]，原因在上文有说过  
        return pos  
    return player  
 
player = create()  # 创建棋子player，起点为原点  
print player([1,0],10)  # 向x轴正方向移动10步  
print player([0,1],20)  # 向y轴正方向移动20步  
print player([-1,0],10)  # 向x轴负方向移动10步
```

输出为
```
[10, 0]  
[10, 20]  
[0, 20] 
```
* **闭包可以根据外部作用域的局部变量来得到不同的结果**

这有点像一种类似配置功能的作用，我们可以修改外部的变量，闭包根据这个变量展现出不同的功能。比如有时我们需要对某些文件的特殊行进行分析，先要提取出这些特殊行。

```
def make_filter(keep):  
    def the_filter(file_name):  
        file = open(file_name)  
        lines = file.readlines()  
        file.close()  
        filter_doc = [i for i in lines if keep in i]  
        return filter_doc  
    return the_filter
```
如果我们需要取得文件"result.txt"中含有"pass"关键字的行，则可以这样使用例子程序
```
filter = make_filter("pass")  
filter_result = filter("result.txt")  
```
以上两种使用场景，用面向对象也是可以很简单的实现的，但是在用Python进行函数式编程时，闭包对数据的持久化以及按配置产生不同的功能，是很有帮助的。


## 4.7 高阶函数
### 1、map/reduce
Python内建了map()和reduce()函数。

如果你读过Google的那篇大名鼎鼎的论文“[MapReduce: Simplified Data Processing on Large Clusters](http://research.google.com/archive/mapreduce.html)”，你就能大概明白map/reduce的概念。

* **map()**

**map()** 会根据提供的函数对指定序列做映射。
第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。

map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

举例说明，比如我们有一个函数f(x)=x*x，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：
          ![图片](https://uploader.shimo.im/f/wULyUpbHGAE0hRqn.png!thumbnail)
现在，我们用Python代码实现：
```
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```
map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。

你可能会想，不需要map()函数，写一个循环，也可以计算出结果：
```
L = []
for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:
    L.append(f(n))
print(L)
```
的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？

所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x*x，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：
```
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
```
只需要一行代码。

* **reduce****()**

reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收**两个参数**，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
**reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)**

比方说对一个序列求和，就可以用reduce实现：
```
from functools import reduce
def add(x, y):
    print('{}+{}={}'.format(x,y,x + y))
    return x + y
reduce(add, [1, 3, 5, 7, 9])
```
输出
```
1+3=4
4+5=9
9+7=16
16+9=25
```

当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。
但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：
```
from functools import reduce
def fn(x, y):
    print('{}*10+{}={}'.format(x,y,x * 10 + y))
    return x * 10 + y
reduce(fn, [1, 3, 5, 7, 9])
```
输出：
```
1*10+3=13
13*10+5=135
135*10+7=1357
1357*10+9=13579
```

这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：
```
from functools import reduce
def fn(x, y):
    print('{}*10+{}={}'.format(x,y,x * 10 + y))
    return x * 10 + y
def char2num(s):
    digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
    print('digits[{}] = {}'.format(s,digits[s]))
    return digits[s]
reduce(fn, map(char2num, '13579'))
```
输出：
```
digits[1] = 1
digits[3] = 3
1*10+3=13
digits[5] = 5
13*10+5=135
digits[7] = 7
135*10+7=1357
digits[9] = 9
1357*10+9=13579
```

整理成一个str2int的函数就是：
```
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
```
还可以用lambda函数进一步简化成：
```
from functools import reduce

DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```
也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！

### 2、filter()
Python内建的filter()函数用于过滤序列。

和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
```
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```
把一个序列中的空字符串删掉，可以这么写：
```
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']
```
可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。
注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。

### 3、sorted
排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。

Python内置的sorted()函数就可以对list进行排序：
```
>>> sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
```
此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
```
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```
key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：
```
list = [36, 5, -12, 9, -21]

keys = [36, 5,  12, 9,  21]
```
然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：
![图片](https://uploader.shimo.im/f/SURAuTfBAOY9yHgz.png!thumbnail)
我们再看一个字符串排序的例子：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
```
默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。

现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
这样，我们给sorted传入key函数，即可实现忽略大小写的排序：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
```
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
```
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```
从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。

## 4.8  装饰器
### 1、什么是装饰器
通过一个需求，一步一步来了解 Python 装饰器。首先有这么一个输出员工打卡信息的函数：
```
def punch():
    print('昵称：小明  部门：研发部 上班打卡成功')
punch()
```
输出的结果：
```
昵称：小明  部门：研发部 上班打卡成功
```
然后，产品反馈，不行啊，怎么上班打卡没有具体的日期，加上打卡的具体日期吧，这应该很简单，分分钟解决啦。好吧，那就直接添加打印日期的代码吧，如下：
```
import time

def punch():
    print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
    print('昵称：小明  部门：研发部 上班打卡成功')

punch()
```
输出的结果：
```
2018-01-09
昵称：小明  部门：研发部 上班打卡成功
```
这样改是可以，可是这样改是改变了函数的功能结构的，本身这个函数定义的时候就是打印某个员工的信息和提示打卡成功，现在增加打印日期的代码，可能会造成很多代码重复的问题。比如，还有一个地方只需要打印员工信息和打卡成功就行了，不需要日期，那么你又要重写一个函数吗？而且打印当前日期的这个功能方法是经常使用的，是可以作为公共函数给各个模块方法调用的。当然，这都是作为一个整体项目来考虑的。

既然是这样，我们可以使用函数式编程来修改这部分的代码。因为通过之前的学习，我们知道 Python 函数有两个特点，函数也是一个对象，而且函数里可以嵌套函数，那么修改一下代码变成下面这个样子：
```
import time

def punch():
    print('昵称：小明  部门：研发部 上班打卡成功')

def add_time(func):
    print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
    func()

add_time(punch)
```
输出的结果：
```
2018-01-09
昵称：小明  部门：研发部 上班打卡成功
```
这样是不是发现，这样子就没有改动 punch 方法，而且任何需要用到打印当前日期的函数都可以把函数传进 add_time 就可以了。

使用函数编程是不是很方便，但是，我们每次调用的时候，我们都不得不把原来的函数作为参数传递进去，还能不能有更好的实现方式呢？有的，就是要介绍的装饰器，因为装饰器的写法其实跟闭包是差不多的，不过没有了自由变量，那么这里直接给出上面那段代码的装饰器写法，来对比一下，装饰器的写法和函数式编程有啥不同。

```
import time

def decorator(func):
    def punch():
        print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
        func()

    return punch

def punch():
    print('昵称：小明  部门：研发部 上班打卡成功')

f = decorator(punch)
f()
```
输出的结果：
```
2018-01-09
昵称：小明  部门：研发部 上班打卡成功
```
通过代码，能知道装饰器函数一般做这三件事：
1. 接收一个函数作为参数
2. 嵌套一个包装函数, 包装函数会接收原函数的相同参数，并执行原函数，且还会执行附加功能
3. 返回嵌套函数
### 2、语法糖
我们看上面的代码可以知道， Python 在引入装饰器 （Decorator） 的时候，没有引入任何新的语法特性，都是基于函数的语法特性。这也就说明了装饰器不是 Python 特有的，而是每个语言通用的一种编程思想。

只不过 Python 设计出了** ****@****语法糖**，**让定义装饰器，把装饰器调用原函数再把结果赋值为原函数的对象名的过程**变得更加简单，方便，易操作，所以 Python 装饰器的核心可以说就是它的语法糖。

那么怎么使用它的语法糖呢？很简单，根据上面的写法写完装饰器函数后，直接在原来的函数上加 @ 和装饰器的函数名。如下：
```
import time

def decorator(func):
    def punch():
        print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
        func()

    return punch

@decorator
def punch():
    print('昵称：小明  部门：研发部 上班打卡成功')

punch()
```
输出结果：
```
2018-01-09
昵称：小明  部门：研发部 上班打卡成功
```
那么这就很方便了，方便在我们的调用上，比如例子中的，使用了装饰器后，直接在原本的函数上加上装饰器的语法糖就可以了，本函数也无虚任何改变，调用的地方也不需修改。

不过这里一直有个问题，就是输出打卡信息的是固定的，那么我们需要通过参数来传递，装饰器该怎么写呢？装饰器中的函数可以使用 ***args**** **可变参数，可是仅仅使用 *args 是不能完全包括所有参数的情况，比如关键字参数就不能了，为了能兼容关键字参数，我们还需要加上 ****kwargs** 。
因此，装饰器的最终形式可以写成这样：
```
import time

def decorator(func):
    def punch(*args, **kwargs):
        print(time.strftime('%Y-%m-%d', time.localtime(time.time())))
        func(*args, **kwargs)

    return punch

 
@decorator
def punch(name, department):
    print('昵称：{0}  部门：{1} 上班打卡成功'.format(name, department))

@decorator
def print_args(reason, **kwargs):
    print(reason)
    print(kwargs)

punch('小明', '研发部')
print_args('小明', sex='男', age=99)
```
输出的结果：
```
2018-01-09
昵称：小明  部门：研发部 上班打卡成功
2018-01-09
小明
{'sex': '男', 'age': 99}
```


